Pitch shifting in Web Audio API
Published 2020-02-23  Last updated 2021-06-07  Revisions
Using samples is a quick and easy way to create realistic sounding virtual instruments. We only need a couple of samples, typically recordings of individual notes played on a real instrument, which can then be pitch shifted to play any note. This article will teach you how to create a sample-based instrument using JavaScript and Web Audio API.

Changing the pitch
Let's begin by loading a sample and playing it. We'll use a recording of note C4 played on harpsichord by pjcohen licensed under CC0 1.0.

const context = new AudioContext();

function loadSample(url) {
  return fetch(url)
    .then(response => response.arrayBuffer())
    .then(buffer => context.decodeAudioData(buffer));
}

function playSample(sample) {
  const source = context.createBufferSource();
  source.buffer = sample;
  source.connect(context.destination);
  source.start(0);
}

loadSample('harpsichord-c4.wav')
  .then(sample => playSample(sample));
The above example code is simplified. Check out the full source code to see how to support Safari and old Chrome versions and read my article on different audio formats.

How can we modify the pitch of the sample? When looking for available options, detune property of AudioBufferSourceNode seems to be the obvious answer. However, it has a couple of major drawbacks:

Safari does not support detune at all (see WebKit bug 193445).
Firefox does support detune but its range is limited to one octave (see Firefox bug 1624681). This limitation comes from an old specification of Web Audio API so other browsers (or their old versions) may also have the same limitation.
Instead of using detune, we'll use the better supported playbackRate property for pitch shifting. For example, setting playbackRate to 2 will play the sample twice as fast and 0.5 will halve the speed.

function playSample(sample, rate) {
  const source = context.createBufferSource();
  source.buffer = sample;
  source.playbackRate.value = rate;
  source.connect(context.destination);
  source.start(0);
}
playSample(sample, 0.5);
Test different playback rates below:


Make it musical
We can now change the pitch of the sample by changing its playback rate. But which playback rate should we use to play a specific musical note? To answer this, we need to understand how the frequencies of pitches are related to each other.

Let's start with the fundamental relationship between frequencies: an octave. An octave means that the ratio between two frequencies is 2:1. In other words the playback rate for one octave higher is 2 and for two octaves higher it's 4. Likewise, the playback rate for one octave lower is 0.5 and for two octaves lower it's 0.25. We can express this as the following function:

playback-rate
(
octaves
)
=
2
octaves
playback-rate(octaves)=2 
octaves
 

In western music each octave is divided into 12 equal parts called semitones. This can be expressed with a small modification to the previous function:

playback-rate
(
semitones
)
=
2
semitones
/
12
playback-rate(semitones)=2 
semitones/12
 

Typically, we think in terms of absolute pitches like C4 or D4. We can represent these pitches as MIDI notes 60 and 62. Now it's easy to calculate their difference of 2 semitones. In general the playback rate required to play MIDI note 
a
a using a sample of MIDI note 
b
b is the following:

playback-rate
(
a
,
b
)
=
2
(
a
−
b
)
/
12
playback-rate(a,b)=2 
(a−b)/12
 

Let's turn this into code:

function playSample(sample, sampleNote, noteToPlay) {
  const source = context.createBufferSource();
  source.buffer = sample;
  source.playbackRate.value = 2 ** ((noteToPlay - sampleNote) / 12);
  source.connect(context.destination);
  source.start(0);
}
playSample(sample, 60, 62);
Now we can use this function to build complete musical instruments.