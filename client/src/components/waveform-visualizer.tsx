import React, { useEffect, useRef, useMemo, useState } from 'react';
import type { SongWithTracks } from '@shared/schema';
import { waveformGenerator } from '@/lib/waveform-generator';

interface WaveformVisualizerProps {
  song: SongWithTracks | null;
  currentTime: number;
  isPlaying: boolean;
  audioLevels?: Record<string, number>;
  className?: string;
}

export function WaveformVisualizer({ 
  song, 
  currentTime, 
  isPlaying, 
  audioLevels = {},
  className = ""
}: WaveformVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameRef = useRef<number>();
  const [waveformData, setWaveformData] = useState<number[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);

  // Cache and waveform generation is now handled by waveformGenerator utility

  // Use cached waveform or generate new one
  useEffect(() => {
    if (!song) {
      setWaveformData([]);
      return;
    }

    // Check for cached waveform first (auto-generated by audio engine)
    const cachedData = waveformGenerator.getCachedWaveform(song.id);
    if (cachedData) {
      console.log(`Loading cached waveform for "${song.title}" (${cachedData.length} data points)`);
      setWaveformData(cachedData);
      setIsGenerating(false);
      return;
    }

    // If no cache found, generate waveform (should rarely happen now due to auto-generation)
    if (song.tracks.length > 0) {
      console.log(`No cached waveform found for "${song.title}", generating...`);
      setIsGenerating(true);
      waveformGenerator.generateWaveformFromSong(song).then((waveformData) => {
        setWaveformData(waveformData);
        setIsGenerating(false);
      }).catch((error) => {
        console.error(`Failed to generate waveform for "${song.title}":`, error);
        setWaveformData([]);
        setIsGenerating(false);
      });
    } else {
      // No tracks and no cache - show empty waveform
      console.log(`No tracks or cached waveform for "${song.title}"`);
      setWaveformData([]);
      setIsGenerating(false);
    }
  }, [song?.id]); // Only trigger on song change, not track count changes

  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas || !song) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const duration = song.duration || 240;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Show loading state
    if (isGenerating) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.7)';
      ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Generating waveform from audio...', width / 2, height / 2);
      return;
    }

    // Show message if no waveform data and no song
    if (waveformData.length === 0 && !song) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
      ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Select a song to see waveform', width / 2, height / 2);
      return;
    }

    // If we have a song but no waveform data, something went wrong - show placeholder
    if (waveformData.length === 0 && song) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
      ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Waveform unavailable', width / 2, height / 2);
      return;
    }

    // Draw background
    ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // slate-900 with opacity
    ctx.fillRect(0, 0, width, height);

    if (waveformData.length === 0) return;

    const barWidth = width / waveformData.length;
    const centerY = height / 2;
    const maxHeight = height * 0.9; // Use more of the available height

    // Draw waveform bars
    waveformData.forEach((amplitude, index) => {
      const x = index * barWidth;
      const barHeight = amplitude * maxHeight;
      
      // Calculate position in song
      const position = index / waveformData.length;
      const timeAtPosition = position * duration;
      
      // Determine color based on playback position and activity
      let color;
      if (timeAtPosition <= currentTime && isPlaying) {
        // Played portion - use dynamic color based on current audio levels
        const avgLevel = Object.values(audioLevels).reduce((sum, level) => sum + level, 0) / Object.keys(audioLevels).length || 0;
        const intensity = Math.min(1, avgLevel / 50 + 0.3);
        color = `rgba(34, 197, 94, ${intensity})`; // Green with variable intensity
      } else if (timeAtPosition <= currentTime + 5 && isPlaying) {
        // Upcoming section (next 5 seconds) - blue hint
        const proximity = 1 - (timeAtPosition - currentTime) / 5;
        color = `rgba(59, 130, 246, ${proximity * 0.4})`; // Blue with fade
      } else {
        // Unplayed portion - gray
        color = 'rgba(71, 85, 105, 0.6)'; // slate-600
      }

      ctx.fillStyle = color;
      ctx.fillRect(x, centerY - barHeight / 2, Math.max(1, barWidth - 0.5), barHeight);
    });

    // Draw progress line
    if (isPlaying && duration > 0) {
      const progressX = (currentTime / duration) * width;
      
      // Progress line with glow effect
      ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';
      ctx.shadowBlur = 4;
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(progressX, 0);
      ctx.lineTo(progressX, height);
      ctx.stroke();
      
      // Reset shadow
      ctx.shadowBlur = 0;
    }

    // Draw time indicators
    if (duration > 0) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.7)'; // slate-400
      ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      
      // Draw time markers every 30 seconds
      const interval = 30;
      for (let time = 0; time <= duration; time += interval) {
        const x = (time / duration) * width;
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        const timeLabel = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        if (x > 25 && x < width - 25) { // Don't draw too close to edges
          ctx.fillText(timeLabel, x, height - 6);
        }
      }
    }
  };

  useEffect(() => {
    const animate = () => {
      draw();
      if (isPlaying) {
        animationFrameRef.current = requestAnimationFrame(animate);
      }
    };

    animate();

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [song, currentTime, isPlaying, audioLevels, waveformData]);

  // Redraw when not playing but data changes
  useEffect(() => {
    if (!isPlaying) {
      draw();
    }
  }, [song, currentTime, waveformData]);

  if (!song || song.tracks.length === 0) {
    return (
      <div className={`bg-slate-900/80 rounded-lg border border-slate-700 ${className}`}>
        <div className="flex items-center justify-center h-full text-slate-400 text-sm">
          Load a song to see waveform
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-slate-900/80 rounded-lg border border-slate-700 overflow-hidden ${className}`}>
      <canvas
        ref={canvasRef}
        width={400}
        height={60}
        className="w-full h-full"
        style={{ display: 'block', height: '60px' }}
      />
    </div>
  );
}