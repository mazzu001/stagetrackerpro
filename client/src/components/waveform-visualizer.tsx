import React, { useEffect, useRef, useMemo, useState } from 'react';
import type { SongWithTracks } from '@shared/schema';
import { waveformGenerator } from '@/lib/waveform-generator';

interface WaveformVisualizerProps {
  song: SongWithTracks | null;
  currentTime: number;
  isPlaying: boolean;
  audioLevels?: Record<string, number>;
  className?: string;
  onSeek?: (time: number) => void;
}

export function WaveformVisualizer({ 
  song, 
  currentTime, 
  isPlaying, 
  audioLevels = {},
  className = "",
  onSeek
}: WaveformVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameRef = useRef<number>();
  const [waveformData, setWaveformData] = useState<number[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isHovering, setIsHovering] = useState(false);
  const [previewPosition, setPreviewPosition] = useState<number | null>(null);

  // Cache and waveform generation is now handled by waveformGenerator utility

  // Use cached waveform or generate new one
  useEffect(() => {
    if (!song) {
      setWaveformData([]);
      return;
    }

    // Check for cached waveform first (auto-generated by audio engine)
    const cachedData = waveformGenerator.getCachedWaveform(song.id);
    if (cachedData) {
      console.log(`Loading cached waveform for "${song.title}" (${cachedData.length} data points)`);
      setWaveformData(cachedData);
      setIsGenerating(false);
      return;
    }

    // If no cache found, generate waveform (should rarely happen now due to auto-generation)
    if (song.tracks.length > 0) {
      console.log(`No cached waveform found for "${song.title}", generating...`);
      setIsGenerating(true);
      waveformGenerator.generateWaveformFromSong(song).then((waveformData) => {
        setWaveformData(waveformData);
        setIsGenerating(false);
      }).catch((error) => {
        console.error(`Failed to generate waveform for "${song.title}":`, error);
        setWaveformData([]);
        setIsGenerating(false);
      });
    } else {
      // No tracks and no cache - show empty waveform
      console.log(`No tracks or cached waveform for "${song.title}"`);
      setWaveformData([]);
      setIsGenerating(false);
    }
  }, [song?.id]); // Only trigger on song change, not track count changes

  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas || !song) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const duration = song.duration || 240;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Show loading state
    if (isGenerating) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.7)';
      ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Generating waveform from audio...', width / 2, height / 2);
      return;
    }

    // Show message if no waveform data and no song
    if (waveformData.length === 0 && !song) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
      ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Select a song to see waveform', width / 2, height / 2);
      return;
    }

    // If we have a song but no waveform data, something went wrong - show placeholder
    if (waveformData.length === 0 && song) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
      ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Waveform unavailable', width / 2, height / 2);
      return;
    }

    // Draw background
    ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // slate-900 with opacity
    ctx.fillRect(0, 0, width, height);

    if (waveformData.length === 0) return;

    const barWidth = width / waveformData.length;
    const centerY = height / 2;
    const maxHeight = height * 0.9; // Use more of the available height

    // Draw waveform bars
    waveformData.forEach((amplitude, index) => {
      const x = index * barWidth;
      const barHeight = amplitude * maxHeight;
      
      // Calculate position in song
      const position = index / waveformData.length;
      const timeAtPosition = position * duration;
      
      // Determine color based on playback position and activity
      let color;
      if (timeAtPosition <= currentTime && isPlaying) {
        // Played portion - use dynamic color based on current audio levels
        const avgLevel = Object.values(audioLevels).reduce((sum, level) => sum + level, 0) / Object.keys(audioLevels).length || 0;
        const intensity = Math.min(1, avgLevel / 50 + 0.3);
        color = `rgba(34, 197, 94, ${intensity})`; // Green with variable intensity
      } else if (timeAtPosition <= currentTime + 5 && isPlaying) {
        // Upcoming section (next 5 seconds) - blue hint
        const proximity = 1 - (timeAtPosition - currentTime) / 5;
        color = `rgba(59, 130, 246, ${proximity * 0.4})`; // Blue with fade
      } else {
        // Unplayed portion - gray, with subtle highlight when hovering and interactive
        const isInteractive = !isPlaying && onSeek && waveformData.length > 0;
        const baseOpacity = isInteractive && isHovering ? 0.8 : 0.6;
        color = `rgba(71, 85, 105, ${baseOpacity})`; // slate-600
      }

      ctx.fillStyle = color;
      ctx.fillRect(x, centerY - barHeight / 2, Math.max(1, barWidth - 0.5), barHeight);
    });

    // Draw progress line
    if (isPlaying && duration > 0) {
      const progressX = (currentTime / duration) * width;
      
      // Progress line with glow effect
      ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';
      ctx.shadowBlur = 4;
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(progressX, 0);
      ctx.lineTo(progressX, height);
      ctx.stroke();
      
      // Reset shadow
      ctx.shadowBlur = 0;
    }

    // Draw preview line when hovering (only when interactive)
    if (!isPlaying && previewPosition !== null && onSeek && waveformData.length > 0) {
      const previewX = previewPosition * width;
      
      // Preview line with subtle glow
      ctx.shadowColor = 'rgba(59, 130, 246, 0.6)';
      ctx.shadowBlur = 3;
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'; // Blue preview line
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]); // Dashed line to differentiate from progress
      ctx.beginPath();
      ctx.moveTo(previewX, 0);
      ctx.lineTo(previewX, height);
      ctx.stroke();
      
      // Reset line dash and shadow
      ctx.setLineDash([]);
      ctx.shadowBlur = 0;
    }

    // Draw time indicators
    if (duration > 0) {
      ctx.fillStyle = 'rgba(148, 163, 184, 0.7)'; // slate-400
      ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      
      // Draw time markers every 30 seconds
      const interval = 30;
      for (let time = 0; time <= duration; time += interval) {
        const x = (time / duration) * width;
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        const timeLabel = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        if (x > 25 && x < width - 25) { // Don't draw too close to edges
          ctx.fillText(timeLabel, x, height - 6);
        }
      }
    }
  };

  useEffect(() => {
    const animate = () => {
      draw();
      if (isPlaying) {
        animationFrameRef.current = requestAnimationFrame(animate);
      }
    };

    animate();

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [song, currentTime, isPlaying, audioLevels, waveformData, isHovering, previewPosition]);

  // Redraw when not playing but data changes
  useEffect(() => {
    if (!isPlaying) {
      draw();
    }
  }, [song, currentTime, waveformData, isHovering, previewPosition]);

  // Calculate position from mouse/touch coordinates
  const getPositionFromEvent = (event: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement> | MouseEvent | TouchEvent) => {
    const canvas = canvasRef.current;
    if (!canvas || !song) return null;

    const rect = canvas.getBoundingClientRect();
    let clientX: number;

    // Handle both mouse and touch events
    if ('touches' in event) {
      if (event.touches.length === 0) return null;
      clientX = event.touches[0].clientX;
    } else {
      clientX = event.clientX;
    }

    // Calculate position relative to canvas
    const x = clientX - rect.left;
    const canvasWidth = rect.width;
    
    // Convert X position to normalized position (0-1)
    return Math.max(0, Math.min(1, x / canvasWidth));
  };

  // Handle mouse movement for preview
  const handleMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (!song || !onSeek || isPlaying || waveformData.length === 0) {
      setPreviewPosition(null);
      return;
    }

    const position = getPositionFromEvent(event);
    setPreviewPosition(position);
  };

  // Handle touch movement for preview
  const handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {
    if (!song || !onSeek || isPlaying || waveformData.length === 0) {
      setPreviewPosition(null);
      return;
    }

    event.preventDefault(); // Prevent scrolling while dragging
    const position = getPositionFromEvent(event);
    setPreviewPosition(position);
  };

  // Handle click/touch events for seeking
  const handleCanvasInteraction = (event: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    if (!song || !onSeek || isPlaying || waveformData.length === 0) return;

    const position = getPositionFromEvent(event);
    if (position === null) return;
    
    // Convert position to time and seek
    const duration = song.duration || 240;
    const seekTime = position * duration;
    onSeek(seekTime);
  };

  if (!song || song.tracks.length === 0) {
    return (
      <div className={`bg-slate-900/80 rounded-lg border border-slate-700 ${className}`}>
        <div className="flex items-center justify-center h-full text-slate-400 text-sm">
          Load a song to see waveform
        </div>
      </div>
    );
  }

  return (
    <div className="bg-slate-900/80 overflow-hidden border border-gray-600 rounded w-full h-[68px] mt-[-10px] mb-[-10px] pt-[4px] pb-[4px]">
      <canvas
        ref={canvasRef}
        width={400}
        height={60}
        className="w-full h-full"
        style={{ 
          display: 'block', 
          height: '60px',
          cursor: !isPlaying && song && waveformData.length > 0 && onSeek ? 'pointer' : 'default'
        }}
        onClick={handleCanvasInteraction}
        onTouchStart={handleCanvasInteraction}
        onMouseMove={handleMouseMove}
        onTouchMove={handleTouchMove}
        onMouseEnter={() => setIsHovering(true)}
        onMouseLeave={() => {
          setIsHovering(false);
          setPreviewPosition(null);
        }}
        onTouchEnd={() => setPreviewPosition(null)}
      />
    </div>
  );
}